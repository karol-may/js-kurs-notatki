---
layout: page
title: "0. sylabus"
permalink: /lessons/sylabus/
---

# Sylabus podstawowego kursu JavaScript

## Cele ogólne

Zrozumienie podstaw języka `JavaScript` — poznanie typów danych, zmiennych, operatorów, struktur sterujących i funkcji jako fundamentów języka.
Tworzenie interaktywnych aplikacji w przeglądarce — opanowanie pracy z `DOM`, zdarzeniami, formularzami, przetwarzaniem danych i `API`.
Rozwijanie umiejętności programowania funkcyjnego i obiektowego — stosowanie klas, funkcji wyższego rzędu, domknięć oraz struktur danych takich jak tablice, obiekty, zbiory i mapy.
Rozwiązywanie problemów programistycznych — analizowanie błędów, debugowanie kodu, projektowanie rozwiązań i logiczne myślenie w procesie tworzenia aplikacji.
Integracja z usługami zewnętrznymi — wykorzystanie `Web API`, asynchroniczność (`async`/`await`, `Promises`), obsługa `fetch`, `JWT`, `FormData`.

## Cele operacyjne

- Deklarować i operować na zmiennych z wykorzystaniem `var`, `let`, `const`, rozumiejąc zasady hoistingu i zakresu (`scope`).
- Tworzyć logiczne konstrukcje kodu — instrukcje warunkowe, pętle, operatory logiczne i arytmetyczne.
- Przetwarzać różne typy danych — stringi, liczby, daty, typy złożone (tablice, obiekty), konwertować między typami.
- Tworzyć i stosować funkcje — nazwane, anonimowe, strzałkowe; przekazywać je jako argumenty; stosować domknięcia i rekurencję.
- Programować obiektowo — tworzyć klasy, korzystać z dziedziczenia, enkapsulacji i metod.
- Reagować na działania użytkownika — obsługa zdarzeń, delegacja, kontrola przepływu zdarzeń w `DOM`.
- Wykonywać operacje na danych z formularzy i serwerów — użycie `fetch`, `FormData`, `JSON`, komunikacja z backendem.
- Wdrażać bezpieczeństwo aplikacji — stosować `JWT`, zarządzać autoryzacją i cyklem życia tokenów.
- Analizować i naprawiać błędy — debugować kod, stosować `try...catch`, analizować wyjątki i komunikaty błędów.
- Projektować strukturę aplikacji — korzystać z modułów, przemyślanie organizować kod i korzystać z `Web API`.
## Materiał nauczania

| Nr  | Temat                                      | Efekt kształcenia                                                                                                               | Kryteria weryfikacji                                                                                                                                                                                                                                                        | Podstawowe wymagania programowe (Słuchacz potrafi)                                                                                                                                               | Ponadpodstawowe wymagania programowe                                                                                                                                                                          |
| --- |--------------------------------------------| ------------------------------------------------------------------------------------------------------------------------------- |-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------| ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| 1   | Deklaracja zmiennych `var`, `let`, `const` | Dokonuje świadomego wyboru rodzaju deklaracji zmiennej w zależności od kontekstu wykonania oraz wymagań semantycznych.          | Analizuje zakresy leksykalne zmiennych (`scope`); Interpretuje `hoisting` i jego wpływ na inicjalizację zmiennych; Uzasadnia użycie `const` w kontekście niezmienności referencji; Dyskutuje implikacje mutowalności i niemutowalności.                                     | Słuchacz potrafi zadeklarować zmienne z użyciem `var`, `let` i `const`; wyjaśnić różnice między nimi w kontekście zakresu i `hoistingu`; wskazać, kiedy stosować `const`, a kiedy `let`.         | Słuchacz uzasadnia wpływ `hoistingu` na zachowanie kodu; analizuje konsekwencje wyboru typu deklaracji w kontekście mutowalności i zakresu działania; stosuje `const` zgodnie z zasadą niezmienności referencji.  |
| 2.1 | Blok kodu i zakres leksykalny              | Precyzyjnie definiuje i stosuje złożone struktury blokowe w kodzie programu.                                                    | Rozróżnia zakresy blokowe i funkcyjne; Implementuje mechanizmy sterujące z wykorzystaniem bloków nazwanych; Analizuje zależności widoczności zmiennych względem zasięgu leksykalnego.                                                                                       | Słuchacz potrafi zidentyfikować zakres blokowy; stosować bloki kodu do grupowania instrukcji; wyjaśnić podstawową zależność widoczności zmiennych w ramach bloku.                                | Słuchacz projektuje złożone struktury blokowe uwzględniające zależność leksykalną; analizuje kolizje nazw zmiennych w różnych blokach;                                                                        |
| 2.2 | Scope i hoisting                           | Rozpoznaje i stosuje zasady hoistingu oraz zakresów zmiennych.                                                                  | Demonstruje różnice między zmiennymi hoistowanymi a niehoistowanymi; Przeprowadza analizę fazy kompilacji i wykonania; Wyjaśnia działanie `TDZ` (Temporal Dead Zone).                                                                                                       | Słuchacz potrafi rozróżniać zakresy globalne, funkcyjne i blokowe; wskazać wpływ hoistingu na zachowanie zmiennych; interpretować podstawowe przypadki `TDZ`.                                    | Słuchacz analizuje fazy działania programu (kompilacja i wykonanie) z uwzględnieniem `hoistingu`; projektuje kod z kontrolowanym dostępem do zmiennych; rozwiązuje złożone przypadki błędów wynikających z `TDZ`. |
| 3   | Operatory                                  | Zna i stosuje operatory logiczne, porównania, przypisania i arytmetyczne z uwzględnieniem reguł ich działania oraz priorytetów. | Implementuje logiczne wyrażenia z użyciem operatorów `&&`, `\|\|`, `!`, `??`; Wykorzystuje operatory porównania w kontekście silnej i słabej równości; Przeprowadza obliczenia z użyciem operatorów arytmetycznych i bitowych; Stosuje `typeof`, `instanceof`.              | Słuchacz potrafi tworzyć wyrażenia z użyciem operatorów arytmetycznych i przypisania; stosować operatory porównania i logiczne w warunkach; rozpoznać podstawowe zastosowania `typeof` i `instanceof`. | Słuchacz analizuje złożone wyrażenia z uwzględnieniem priorytetów operatorów; wykorzystuje operatory bitowe w obliczeniach; |
| 4 | Typy danych                                | Identyfikuje, klasyfikuje i stosuje typy danych w kontekście zarządzania pamięcią i semantyki języka. | Rozróżnia typy prymitywne i złożone; Analizuje właściwości `undefined`, `null`, `symbol`, `bigint`; Wykorzystuje `typeof` oraz `Array.isArray()` w diagnostyce typu; Objaśnia zasady przekazywania wartości przez wartość i przez referencję.                               | Słuchacz potrafi rozróżnić typy prymitywne i złożone; stosować `typeof` i `Array.isArray()` do identyfikacji typów; przekazywać dane przez wartość i przez referencję.                           | Słuchacz analizuje wpływ typów danych na zarządzanie pamięcią; diagnozuje trudne przypadki związane z `undefined`, `null` i `symbol`; stosuje `BigInt` do operacji na dużych liczbach. |
| 5.1 | Funkcje                                    | Implementuje funkcje jako elementy logiki biznesowej i funkcjonalnej architektury aplikacji. | Tworzy funkcje nazwane, anonimowe, strzałkowe; Przekazuje funkcje jako argumenty i wartości zwrotne (funkcje wyższego rzędu); Zarządza zakresem zmiennych i wartościami domyślnymi; Tworzy domknięcia (`closures`) i rekurencje.                                            | Słuchacz potrafi tworzyć różne typy funkcji (nazwane, anonimowe, strzałkowe); przekazywać funkcje jako argumenty; stosować zmienne lokalne i domyślne wartości parametrów.                       | Słuchacz projektuje funkcje wyższego rzędu; implementuje rekurencję i domknięcia; analizuje zakres zmiennych w kontekście funkcji zagnieżdżonych. |
| 5.2 | `Async` / `Await`                          | Stosuje asynchroniczne wzorce wykonywania z wykorzystaniem mechanizmu `async`/`await`. | Definiuje funkcje asynchroniczne (`async`); Synchronizuje wykonanie przy pomocy `await`; Obsługuje wyjątki za pomocą `try...catch`; Porównuje `async`/`await` z `Promise.then()`; Analizuje wpływ asynchroniczności na sekwencję operacji.                                  | Słuchacz potrafi zadeklarować funkcję `async`; używać `await` do oczekiwania na wynik; obsłużyć błędy przy użyciu `try...catch`.                                                                 | Słuchacz porównuje `async`/`await` z `then`/`catch`; projektuje sekwencje asynchroniczne z kontrolą błędów; analizuje wpływ `async` na przebieg wykonania programu. |
| 5.3 | Obietnice (`Promise`)                      | Wykorzystuje obiekty `Promise` jako mechanizm zarządzania przepływem asynchronicznym. | Tworzy obiekty `Promise` z `resolve`, `reject`; Łączy operacje przy użyciu `.then()`, `.catch()`, `.finally()`; Analizuje statusy obietnicy; Implementuje łańcuchy zdarzeń i przetwarzanie błędów.                                                                          | Słuchacz potrafi zadeklarować i wykorzystać obiekt `Promise`; obsługiwać wyniki przy użyciu `then()` i `catch()`; rozróżniać stany obietnicy.                                                    | Słuchacz tworzy złożone łańcuchy asynchroniczne z wykorzystaniem `then`/`catch`/`finally`; analizuje przepływ danych i błędów w zagnieżdżonych `Promisach`. |
| 6 | Obiekty                                    | Modeluje dane za pomocą struktur obiektowych zgodnie z zasadami programowania obiektowego. | Tworzy i modyfikuje obiekty oraz ich zagnieżdżenia; Wykorzystuje notację kropkową i nawiasową; Tworzy metody i korzysta z `this`; Iteruje po właściwościach (`for...in`, `Object.keys()` itd.); Stosuje destrukturyzację i `spread`.                                        | Słuchacz potrafi tworzyć obiekty i modyfikować ich właściwości; stosować `this` w kontekście metod; wykorzystywać podstawowe techniki iteracji po obiektach.                                     | Słuchacz tworzy zagnieżdżone struktury obiektowe; stosuje destrukturyzację i `spread`; porównuje efektywność różnych metod iteracji. |
| 7 | Obsługa zdarzeń                            | Implementuje mechanizmy reagowania na zdarzenia w interfejsie użytkownika zgodnie z zasadą reaktywności. | Stosuje `addEventListener` do rejestracji zdarzeń; Obsługuje kontekst zdarzenia przez `event.target`, `event.type`; Implementuje delegację zdarzeń; Zapobiega domyślnym zachowaniom przy użyciu `preventDefault()`; Kontroluje propagację zdarzeń przez `stopPropagation()`. | Słuchacz potrafi zarejestrować i obsłużyć zdarzenia; korzystać z `event.target` i `event.type`; zapobiegać domyślnym zachowaniom.                                                                | Słuchacz stosuje delegację zdarzeń w złożonych interfejsach; kontroluje propagację zdarzeń; projektuje interaktywne mechanizmy reakcji użytkownika. |
| 8 | Ciągi znaków                               | Przetwarza dane tekstowe przy użyciu metod i operatorów właściwych dla typu `string`. | Wykorzystuje operatory konkatenacji i interpolacji (`+`, `${}`); Stosuje metody transformujące (`toUpperCase()`, `trim()`, `replace()`); Rozbija i analizuje tekst (`split()`, `includes()`); Porównuje ciągi znaków w różnych kontekstach językowych.                      | Słuchacz potrafi przetwarzać ciągi znaków; łączyć tekst i stosować metody transformujące; analizować zawartość tekstową.                                                                         | Słuchacz optymalizuje operacje tekstowe; porównuje ciągi z uwzględnieniem lokalizacji językowej; przetwarza dane tekstowe na potrzeby analiz. |
| 9 | Typy numeryczne                            | Posługuje się wartościami liczbowymi w obliczeniach oraz strukturach danych. | Stosuje operacje arytmetyczne i porównania; Konwertuje typy tekstowe na liczby (`parseInt`, `Number()`); Obsługuje liczby zmiennoprzecinkowe i ich ograniczenia; Weryfikuje poprawność liczby przy użyciu `isNaN`, `isFinite`.                                              | Słuchacz potrafi wykonywać podstawowe operacje arytmetyczne i porównania; konwertować tekst na liczby; sprawdzać poprawność wartości liczbowych.                                                 | Słuchacz analizuje ograniczenia liczb zmiennoprzecinkowych; projektuje algorytmy uwzględniające precyzję obliczeń; stosuje zaawansowane walidacje liczb. |
| 10 | Tablice                                    | Zarządza zbiorami danych za pomocą struktur tablicowych. | Tworzy i modyfikuje tablice; Wykorzystuje metody tablicowe (`push`, `map`, `filter`, `reduce`); Iteruje za pomocą pętli i metod funkcyjnych; Analizuje strukturę danych i przekształca tablice wielowymiarowe.                                                              | Słuchacz potrafi tworzyć tablice i stosować podstawowe metody (`push`, `map`, `filter`); iterować po danych przy użyciu pętli i metod funkcyjnych.                                               | Słuchacz przekształca złożone tablice wielowymiarowe; analizuje efektywność operacji na tablicach; projektuje złożone operacje przetwarzania danych tablicowych. |
| 11 | Praca z datami                             | Wykorzystuje obiekt `Date` do reprezentacji i manipulacji czasem. | Tworzy i formatuje daty (`toLocaleDateString`, `toISOString`); Odczytuje wartości daty i czasu (`getFullYear`, `getMonth`); Oblicza różnice między datami; Obsługuje konwersje ciągów na daty.                                                                              | Słuchacz potrafi utworzyć obiekt `Date` i uzyskać podstawowe informacje o czasie; sformatować datę i przeliczyć różnicę między datami.                                                           | Słuchacz analizuje formatowanie dat w różnych lokalizacjach; obsługuje konwersje z różnych źródeł; projektuje logikę przetwarzania danych czasowych. |
| 12 | Obiekt `Math`                              | Stosuje zaawansowane funkcje matematyczne w operacjach arytmetycznych. | Używa metod `Math.round`, `Math.random`, `Math.pow`, `Math.sqrt`; Generuje liczby losowe w zadanym zakresie; Stosuje stałe matematyczne (`Math.PI`, `Math.E`).                                                                                                              | Słuchacz potrafi korzystać z metod obiektu `Math` w podstawowych obliczeniach; generować liczby losowe w określonym zakresie.                                                                    | Słuchacz projektuje algorytmy wykorzystujące funkcje matematyczne; analizuje zastosowania losowości i precyzji w zadaniach obliczeniowych. |
| 13 | Porównania i typ logiczny                  | Tworzy złożone wyrażenia warunkowe przy użyciu operatorów logicznych. | Stosuje `==`, `===`, `!=`, `!==`; Buduje logiczne warunki przy użyciu `&&`, `\|\|`, `!`; Wykorzystuje `??` i operator warunkowy `? :`; Interpretuje wyniki porównań w kontekście konwersji typów.                                                                           | Słuchacz potrafi budować logiczne warunki i porównania; stosować operatory logiczne i warunkowe; interpretować podstawowe przypadki konwersji typów.                                             | Słuchacz analizuje złożone wyrażenia warunkowe; diagnozuje błędy wynikające z niejawnej konwersji typów; projektuje warunki złożone w kodzie aplikacji. |
| 14 | Instrukcje sterujące                       | Projektuje przepływ programu z zastosowaniem instrukcji warunkowych. | Implementuje `if`, `else`, `else if`; Stosuje instrukcję `switch` do wyboru alternatyw; Projektuje złożone konstrukcje decyzyjne; Analizuje sekwencję wykonania programu.                                                                                                   | Słuchacz potrafi zastosować instrukcje warunkowe `if`, `else` i `switch` do sterowania przepływem programu.                                                                                      | Słuchacz projektuje rozbudowane warunki logiczne zagnieżdżone i optymalizuje strukturę decyzyjną kodu. |
| 15 | Pętle                                      | Przetwarza dane iteracyjnie przy pomocy różnorodnych mechanizmów pętli. | Stosuje pętle `for`, `while`, `do...while`; Iteruje po kolekcjach za pomocą `for...of`, `for...in`; Kontroluje wykonanie pętli (`break`, `continue`); Tworzy algorytmy przetwarzania zbiorów danych.                                                                        | Słuchacz potrafi używać pętli `for`, `while` i `do...while` do przetwarzania danych; stosować `break` i `continue`.                                                                              | Słuchacz projektuje złożone pętle z użyciem `for...of` i `for...in`; tworzy algorytmy iteracyjne do operacji na dużych zbiorach. |
| 16 | Zbiory i Mapy                              | Implementuje alternatywne struktury danych – `Set` i `Map`. | Tworzy i przetwarza zbiory (`Set`) i mapy (`Map`); Iteruje po elementach i kluczach; Porównuje właściwości `Set`, `Map` i obiektów zwykłych; Stosuje te struktury do odwzorowywania relacji unikalnych i klucz–wartość.                                                     | Słuchacz potrafi utworzyć i używać zbiorów i map; iterować po ich zawartości.                                                                                                                    | Słuchacz porównuje wydajność `Set`, `Map` i zwykłych obiektów; projektuje zależności z użyciem tych struktur. |
| 17 | Konwersje typu                             | Zarządza konwersjami między typami danych w kontekście dynamicznego typowania JavaScript. | Przeprowadza jawne konwersje (`String`, `Number`, `Boolean`); Rozpoznaje konwersje niejawne w wyrażeniach; Analizuje błędy typowe dla rzutowania; Interpretuje wyniki `typeof` i sprawdza typy wartości.                                                                    | Słuchacz potrafi dokonywać konwersji typów za pomocą konstruktorów; sprawdzać typy zmiennych.                                                                                                    | Słuchacz analizuje skutki niejawnych konwersji; diagnozuje trudne przypadki błędów typowych dla dynamicznego typowania. |
| 18 | Obsługa błędów                             | Implementuje mechanizmy detekcji, propagacji i obsługi wyjątków. | Stosuje konstrukcje `try...catch...finally` do przechwytywania błędów; Rzuca wyjątki za pomocą `throw`; Analizuje komunikaty błędów i kontekst wykonania; Odróżnia błędy składniowe, logiczne i wykonania.                                                                  | Słuchacz potrafi obsługiwać błędy za pomocą `try...catch`; analizować treść komunikatu błędu.                                                                                                    | Słuchacz tworzy własne wyjątki i mechanizmy ich rzucania; klasyfikuje błędy według typu i kontekstu. |
| 19 | `JSON`                                     | Wymienia i przetwarza dane w standardzie `JSON`. | Konwertuje dane z i do `JSON` przy użyciu `JSON.stringify()` oraz `JSON.parse()`; Waliduje strukturę danych; Interpretuje i modyfikuje dane `JSON` przesyłane między aplikacją a serwerem.                                                                                  | Słuchacz potrafi przekształcić obiekt w `JSON` i odwrotnie; analizować podstawową strukturę danych.                                                                                              | Słuchacz waliduje dane w formacie `JSON`; modyfikuje i mapuje złożone obiekty przesyłane między systemami. |
| 20 | Debugowanie                                | Stosuje techniki diagnozowania i korekty błędów. | Używa `console.log()`, `console.error()` oraz narzędzi deweloperskich przeglądarki; Ustawia `breakpoints` i analizuje stos wywołań; Śledzi wartości zmiennych w czasie wykonania programu.                                                                                  | Słuchacz potrafi zlokalizować błąd przy pomocy konsoli i logowania.                                                                                                                              | Słuchacz analizuje wykonanie programu z użyciem `breakpoints` i stosu wywołań; korzysta z narzędzi developerskich do diagnozy złożonych problemów. |
| 21 | Funkcje strzałkowe                         | Tworzy i wykorzystuje funkcje strzałkowe w kontekście funkcyjnym. | Deklaruje funkcje strzałkowe; Porównuje zachowanie `this` względem funkcji tradycyjnych; Stosuje skróconą składnię w metodach tablicowych i wyrażeniach funkcyjnych.                                                                                                        | Słuchacz potrafi zadeklarować funkcję strzałkową; porównać zachowanie `this` w różnych typach funkcji; zastosować skróconą składnię w metodach tablicowych.                                      | Słuchacz wykorzystuje funkcje strzałkowe w złożonych wyrażeniach funkcyjnych; analizuje kontekst `this` i projektuje funkcje w paradygmacie funkcyjnym. |
| 22 | Klasy                                      | Projektuje struktury obiektowe przy użyciu klas. | Tworzy klasy z konstruktorami i metodami; Stosuje dziedziczenie (`extends`, `super()`); Implementuje enkapsulację przez prywatne i publiczne właściwości; Porównuje klasy z funkcjami konstrukcyjnymi.                                                                      | Słuchacz potrafi utworzyć klasę z konstruktorem i metodami; wykorzystać podstawy dziedziczenia.                                                                                                  | Słuchacz implementuje złożone hierarchie klas; projektuje systemy oparte na klasach z kapsułkowaniem i dziedziczeniem. |
| 23 | Moduły                                     | Organizuje kod źródłowy w niezależne i współdzielone komponenty. | Tworzy moduły z użyciem `export` i `import`; Importuje i eksportuje funkcje, klasy, stałe; Tworzy zależności między modułami; Konfiguruje środowisko do pracy z `ES Modules`.                                                                                               | Słuchacz potrafi podzielić kod na moduły i korzystać z podstawowych mechanizmów `export`/`import`.                                                                                               | Słuchacz projektuje architekturę aplikacji opartą na modułach; zarządza zależnościami i organizuje kod w komponenty. |
| 24 | HTML DOM                                   | Pracuje z dokumentem HTML w celu dynamicznej manipulacji drzewem `DOM`. | Wyszukuje elementy `DOM` (`getElementById`, `querySelector`); Modyfikuje zawartość, strukturę i atrybuty elementów; Tworzy i dołącza nowe węzły; Przetwarza kolekcje `DOM` (`NodeList`, `children`).                                                                        | Słuchacz potrafi manipulować elementami `DOM`; dodawać i usuwać elementy; odczytywać oraz ustawiać atrybuty.                                                                                     | Słuchacz projektuje dynamiczne struktury `DOM`; optymalizuje przetwarzanie kolekcji i interakcji z dokumentem HTML. |
| 25 | Browser BOM                                | Interpretuje i modyfikuje właściwości środowiska przeglądarki. | Odczytuje lokalizację (`window.location`), rozmiary (`innerWidth`); Wykorzystuje okna (`alert`, `prompt`); Przechowuje dane (`localStorage`, `cookies`).                                                                                                                    | Słuchacz potrafi odczytać i modyfikować podstawowe właściwości `BOM`; korzystać z `alert` i `prompt`.                                                                                            | Słuchacz wykorzystuje `localStorage` i `cookies` do przechowywania danych; analizuje środowisko `BOM` w kontekście `UX` i bezpieczeństwa. |
| 26.1 | Web APIs                                   | Integruje z interfejsami `API` dostępnymi w przeglądarce. | Stosuje `fetch` do komunikacji z serwerem; Używa `FormData` do obsługi formularzy; Wykorzystuje `Storage API`, `Web Workers`; Zarządza asynchronicznością i bezpieczeństwem transmisji danych.                                                                              | Słuchacz potrafi korzystać z `fetch` i `FormData` do prostych operacji z danymi.                                                                                                                 | Słuchacz projektuje komunikację z `API` z użyciem różnych `Web API`; zarządza bezpieczeństwem i asynchronicznością. |
| 26.2 | Fetch                                      | Implementuje komunikację klient-serwer z użyciem `fetch`. | Wysyła żądania `HTTP` metodą `GET`/`POST`; Obsługuje odpowiedzi i konwertuje do `JSON`; Obsługuje błędy sieciowe i logikę odpowiedzi; Modyfikuje nagłówki (`headers`) i parametry żądania.                                                                                  | Słuchacz potrafi wysłać zapytanie `HTTP` przy użyciu `fetch`; przetworzyć odpowiedź `JSON`.                                                                                                      | Słuchacz obsługuje złożone przypadki błędów i nagłówków; zarządza logiką komunikacji z `API`. |
| 26.3 | JWT                                        | Używa tokenów `JWT` do uwierzytelniania i autoryzacji. | Dołącza token `JWT` w nagłówku `Authorization`; Zarządza cyklem życia tokenów; Obsługuje błędy autoryzacyjne; Interpretuje strukturę tokenu `JWT`.                                                                                                                          | Słuchacz potrafi dołączyć token `JWT` do zapytania; zidentyfikować błąd autoryzacyjny.                                                                                                           | Słuchacz zarządza cyklem życia tokenów; projektuje bezpieczne mechanizmy uwierzytelniania oparte na `JWT`. |
| 26.4 | FormData                                   | Obsługuje dane formularzy i ich transmisję. | Tworzy instancję `FormData`; Dołącza dane i pliki; Przesyła dane metodą `fetch`; Iteruje po parach klucz–wartość przesyłanych danych.                                                                                                                                       | Słuchacz potrafi utworzyć `FormData`, dodać dane i przesłać je przy użyciu `fetch`.                                                                                                              | Słuchacz projektuje i implementuje złożone formularze przesyłające dane i pliki; zarządza strukturą danych przesyłanych przez `FormData`. |

